#@ load("@ytt:data", "data")
#@ load("secrets.star", "sec")

#@ d = data.values
#@ host = d.environment.hosts[0]
---
ingress:
  enabled: true

  traefikCRD:
    enabled: true
    disableIngressRoute: true

  tls:
    enabled: false

pod:
  kind: Deployment
  replicas: 1
  strategy:
    type: Recreate

configMap:
  theme: auto
  authentication_backend:
    file:
      enabled: true
      watch: true

  session:
    cookies:
      - domain: #@ host
        subdomain: auth

  storage:
    local:
      enabled: true

  totp:
    issuer: #@ host

  notifier:
    smtp:
      address: submissions://smtp.gmail.com:465
      enabled: true
      username: #@ sec.sops("smtp", "username")
      #! NOTE: this has no effect as GMail replaces the sender with the authenticated user.
      sender: #@ "authelia@mail." + host

  identity_providers:
    oidc:
      enabled: true
      jwks:
        - key_id: default
          algorithm: RS256
          key:
            value: #@ sec.sopsy("oidc", "jwks.default.key", ["indent 10"])
      clients:
        - client_id: #@ sec.sopsy("oidc", "harbor.client_id")
          client_name: Harbor
          #! The chart has a validation preventing usage of a placeholder here.
          client_secret: $pbkdf2-sha512$310000$9DHdvTgaGh3aUcHDMrgAaQ$GGR6taK64IoVw9.xRAtGA1fPfZKvJguYcFlNuiwn1py0ug.A2csjIiqanEBFSO4D.fGGm7KttN.6lc/ngc3wYg
          pre_configured_consent_duration: 1y
          public: false
          authorization_policy: two_factor
          require_pkce: false
          pkce_challenge_method:
          redirect_uris:
            - https://oci.zebradil.dev/c/oidc/callback
          scopes:
            - openid
            - offline_access
            - profile
            - groups
            - email
          response_types:
            - code
          grant_types:
            - authorization_code
            - refresh_token
          access_token_signed_response_alg: none
          userinfo_signed_response_alg: none
          token_endpoint_auth_method: client_secret_post

        - client_id: #@ sec.sopsy("oidc", "argocd.client_id")
          client_name: 'Argo CD'
          #! The chart has a validation preventing usage of a placeholder here.
          client_secret: $pbkdf2-sha512$310000$fHljICwmWYJUU1clgDqrqg$X2z6OFvOd2PTz.O3aDD1EdXZsZW/2u1./.r1DlUG7Rcel/rya3HoKuopX3JFW002/oEn8jIn.hEhpCeQyuDfwg
          pre_configured_consent_duration: 1y
          public: false
          authorization_policy: two_factor
          require_pkce: false
          redirect_uris:
            - https://argocd.zebradil.dev/auth/callback
          scopes:
            - openid
            - groups
            - email
          response_types:
            - code
          grant_types:
            - authorization_code
          access_token_signed_response_alg: none
          userinfo_signed_response_alg: none
          token_endpoint_auth_method: client_secret_basic
        - client_id: #@ sec.sopsy("oidc", "argocd-cli.client_id")
          client_name: Argo CD (CLI)
          pre_configured_consent_duration: 1y
          public: true
          authorization_policy: two_factor
          require_pkce: true
          pkce_challenge_method: S256
          redirect_uris:
            - http://localhost:8085/auth/callback
          scopes:
            - openid
            - offline_access
            - groups
            - email
          response_types:
            - code
          grant_types:
            - authorization_code
            - refresh_token
          access_token_signed_response_alg: none
          userinfo_signed_response_alg: none
          token_endpoint_auth_method: none

  access_control:
    default_policy: deny
    rules:
      - domain: #@ "*." + host
        subject:
          - group:dev
          - group:admins
        policy: two_factor

secret:
  existingSecret: authelia

#! For the "file" authentication backend.
persistence:
  enabled: true
  #! Minimum size with synology-csi is 1Gi.
  size: 1Gi
